#include <iostream>
#include <iomanip>
using namespace std;

// ДРП (Поле)
// 500 - Блоки
// 999 - Точка В
// -5 - Точка А
// 998 - Поиск минимального пути
//A:(2;15)-колодец
int matr[22][22] = { 
{ 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888 },
{ 888,   0  ,    0 ,  0   ,  0   ,  0   ,  0   ,  0   ,  0   ,  0   ,  0   ,  0   ,  0   ,  0   , 500,  500, 500, 500, 0   , 0    , 0    , 888 },
{ 888,   0  , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    ,  0   , 0    , 0    , 0    , 500, 0     , 500, 0    ,500, 0    , 0    , 888 },
{ 888, 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 500 , 500, 0    ,0    , 0    , 0    , 888},
{ 888, 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0    ,0    , 0    , 0    , 888 },
{ 888, 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0    , 0   , 0    , 0    , 888 },
{ 888, 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0    , 0   , 0    , 0    , 888 },
{ 888, 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0    , 0   , 0     , 0   , 888 },
{ 888, 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0    , 0   , 0     , 0    , 888 },
{ 888, 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0    , 0   , 0     , 0    , 888 },
{ 888, 0    , 0   , 0     ,  0   , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    ,  0    , 0  , 0      , 0   , 888 },
{ 888, 0    , 0   , 0     , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0     , 0  , 0      , 0   , 888 },
{ 888, 0    , 0   , 0     , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0     , 0  , 0       , 0  , 888 },
{ 888, 0    , 0   , 0     , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0     , 0  , 0       , 0  , 888 },
{ 888, 0    , 0   , 0     , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0     , 0  , 0       , 0  , 888 },
{ 888, 0    , 0   , 0     , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 0    , 500, 0     , 0    , 0     , 0  , 0       , 0  , 888 },
{ 888, 0    , 0   , 0     , 0    , 0    , 0    , 0   , 0     , 0    , 0    , 0    , 0    , 0    ,   0, 0     , 0    , 0     , 0  ,  0      ,   0, 888 },
{ 888, 0    , 0   , 0     , 0    , 0    , 0    , 0   , 0     , 0    , 500, 500, 500, 500, 500, 0     , 0    , 0     , 0  , 0       , 0  , 888 },
{ 888, 0    , 0   , 0     , 0    , 0    , 0    , 0   , 0     , 0    , 0    , 0    , 0    , 500, 0    , 0     , 0    , 0     , 0  , 0       , 0  , 888 },
{ 888, 0    , 0   , 0     , 0    , 0    , 0    , 0   , 0     , 0    , 0    , 0    , 0    , 500, 0    , 0     , 0    , 0     , 0  , 0       , 0  , 888 },
{ 888, 0    , 0   , 0     , 0     , 0   , 0   , 0    , 0     , 0     , 0   , 0    , 0    , 500, 0    , 0     , 0    , 0     , 0  , 0       , 0  , 888 },
{ 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888, 888 } };

// Печать поля в цифрах
void print()
{
	for (int i = 1; i < 21; i++)
	{
		for (int j = 1; j < 21; j++)
		{
			// setw(3) добавлено, чтобы матрица выводилась красиво
			cout << setw(3) << matr[i][j] << " ";
		}
		cout << endl;
	}
	cout << endl;
}

// Функция печати поля
void print_matr()
{
	for (int i = 1; i < 21; i++)
	{
		for (int j = 1; j < 21; j++)
		{
			switch (matr[i][j])
			{
			case 500: cout << "* "; break;
			case -5: cout << "A "; break;
			case 999: cout << "B "; break;
			case 998: cout <<" +"; break;
			default: cout << ". ";
			}
		}
		cout << endl;
	}
	cout << endl;
}

// Изменение координат точки A
void setA(int *x, int *y, int *xB, int *yB)
{
	// Ввод координат стоит в цикле, если нарушено какое то услови(точка попадает за поле, попадает на блок,  или...
	// попадает на другую точку, то будет ошибка, и потребуется снова ввести координаты, и так вечно, пока не выполнятся все условия
	bool check = true;

	while (check)
	{
		cout << "Введите координаты А (1 - 20):" << endl;
		cout << "X: "; cin >> *x;
		cout << "Y: "; cin >> *y;


		//Проверка, не попадает ли точка А в точку В
		if ((*xB == *x) && (*yB == *y))
		{
			cout << "ОШИБКА: Точка А совпадает с точкой В, попробуйте снова: " << endl;
			continue;
		}

		// Проверка на выход координат за границы поля
		if ((*x < 1) || (*x > 20))
		{
			cout << "ОШИБКА: Координата Х выходит за границы поля, попробуйте снова: " << endl;
			continue;
		}
		if ((*y < 1) || (*y > 20))
		{
			cout << "ОШИБКА: Координата Y выходит за границы поля, попробуйте снова: " << endl;
			continue;
		}


		// Проверка на попадение точки А в препятствие
		if (matr[*x][*y] == 500)
		{
			cout << "ОШИБКА: Точка А попала на препятствие, повторите снова: " << endl;
		}
		else check = false;
	}

	// Если все условия выполнены, то мы ставим на поле -5, что означает, что это точка А
	matr[*x][*y] = -5;
}

// Изменение координат точки B
void setB(int *x, int *y, int *xA, int *yA)
{
	// Ввод координат стоит в цикле, если нарушено какое то услови(точка попадает за поле, попадает на блок,  или...
	// попадает на другую точку, то будет ошибка, и потребуется снова ввести координаты, и так вечно, пока не выполнятся все условия
	bool check = true;

	while (check)
	{
		cout << "Введите координаты B (1 - 20):" << endl;
		cout << "X: "; cin >> *x;
		cout << "Y: "; cin >> *y;

		//Проверка, не попадает ли точка А в точку В
		if ((*xA == *x) && (*yA == *y))
		{
			cout << "ОШИБКА: Точка B совпадает с точкой A, попробуйте снова: " << endl;
			continue;
		}

		// Проверка на выход координат за границы поля
		if ((*x < 1) || (*x > 20))
		{
			cout << "ОШИБКА: Координата Х выходит за границы поля, попробуйте снова: " << endl;
			continue;
		}
		if ((*y < 1) || (*y > 20))
		{
			cout << "ОШИБКА: Координата Y выходит за границы поля, попробуйте снова: " << endl;
			continue;
		}
		// Проверка на попадение точки В в препятствие
		if (matr[*x][*y] == 500)
		{
			cout << "ОШИБКА: Точка В попала на препятствие, повторите снова: " << endl;
		}
		else check = false;
	}

	// Если все условия выполнены, то мы ставим на поле 999, что означает, что это точка В
	matr[*x][*y] = 999;
}

// Волновой алгоритм
void WAVE(int xA, int yA, int xB, int yB)
{
	int W = 1;

	// Для начала вокруг точки А "вручную" расставляем первую волну
	if ((xA - 1 >= 0) && (matr[xA - 1][yA] == 0)) matr[xA - 1][yA] = 1;
	if ((yA + 1 <= 20) && (matr[xA][yA + 1] == 0)) matr[xA][yA + 1] = 1;
	if ((xA + 1 <= 20) && (matr[xA + 1][yA] == 0)) matr[xA + 1][yA] = 1;
	if ((yA - 1 >= 0) && (matr[xA][yA - 1] == 0)) matr[xA][yA - 1] = 1;

	// Запускаем алгоритм, которые будет искать знчение, которое будет равно ТЕКУЩЕЙ волне. И, если такое значение будет найдено,
	// алгоритм будет расставлять вокруг этой точки следующую волну и так далее, пока не будет заполнено всё поле.
	for (int k = 0; k < 200; k++)
	{
		for (int i = 1; i < 21; i++)
		{
			for (int j = 1; j < 21; j++)
			{
				// Нашли точку, в которой текущая волна
				if (matr[i][j] == W)
				{
					// Если эта точка существует (не за границей, не блок и не другая точка), то ставим следующую волну
					if ((i - 1 >= 0) && (matr[i - 1][j] == 0)) matr[i - 1][j] = W + 1;
					if ((j + 1 <= 20) && (matr[i][j + 1] == 0)) matr[i][j + 1] = W + 1;
					if ((i + 1 <= 20) && (matr[i + 1][j] == 0)) matr[i + 1][j] = W + 1;
					if ((j - 1 >= 0) && (matr[i][j - 1] == 0)) matr[i][j - 1] = W + 1;
				}
			}
		}
		W = W + 1;
	}
}

// Поиск минимального пути
int FIND_WAY(int xB, int yB)
{
	int x = xB, y = yB;

	// Проверка, не стоят ли рядом А и В
	if ((matr[x - 1][y] == -5) || (matr[x][y - 1] == -5) || (matr[x][y + 1] == -5) || (matr[x + 1][y] == -5))
	{
		cout << "Точки А и В стоят рядом" << endl;
		return -1;
	}

	// Проверка на то, что волна вообще дошла от А к В
	if ((matr[x - 1][y] == 0) || (matr[x - 1][y] == 500) || (matr[x - 1][y] == 888))
	if ((matr[x][y - 1] == 0) || (matr[x][y - 1] == 500) || (matr[x][y - 1] == 888))
	if ((matr[x][y + 1] == 0) || (matr[x][y + 1] == 500) || (matr[x][y + 1] == 888))
	if ((matr[x + 1][y] == 0) || (matr[x + 1][y] == 500) || (matr[x + 1][y] == 888))
	{
		cout << "Невозможно найти путь от точки А к точке В" << endl;
		return -1;
	}

	// Поиск минимального значения вокруг клетки, когда это значение находится, оно заменяется на 998, которое потом
	// и трансформируется в "+", что и означает минимальный путь
	while (true)
	{
		// Если точка минимальнее всех остальных, то...
		if ((matr[x - 1][y] <= matr[x][y - 1]) && (matr[x - 1][y] <= matr[x][y + 1]) && (matr[x - 1][y] <= matr[x + 1][y]))
		{
			// Переходим в нее
			x = x - 1;
			y = y;

			// Если мы достигли первой волны, то алгоритм завершается
			if (matr[x][y] == 1)
			{
				matr[x][y] = 998;
				break;
			}
			// Заменяем её на 998 (то есть означает, что это путь минимальный)
			matr[x][y] = 998;
			continue;
		}

		// Если точка минимальнее всех остальных, то...
		if ((matr[x][y + 1] <= matr[x][y - 1]) && (matr[x][y + 1] <= matr[x - 1][y]) && (matr[x][y + 1] <= matr[x + 1][y]))
		{
			// Переходим в нее
			x = x;
			y = y + 1;

			// Если мы достигли первой волны, то  алгоритм завершается
			if (matr[x][y] == 1)
			{
				matr[x][y] = 998;
				break;
			}
			// Заменяем её на 998 (то есть означает, что это путь минимальный)
			matr[x][y] = 998;
			continue;
		}

		// Если точка минимальнее всех остальных, то...
		if ((matr[x][y - 1] <= matr[x + 1][y]) && (matr[x][y + 1] <= matr[x][y + 1]) && (matr[x][y - 1] <= matr[x + 1][y]))
		{
			// Переходим в нее
			x = x;
			y = y - 1;

			// Если мы достигли первой волны, то хватит, алгоритм завершается
			if (matr[x][y] == 1)
			{
				matr[x][y] = 998;
				break;
			}
			// Заменяем её на 998 (то есть означает, что это путь минимальный)
			matr[x][y] = 998;
			continue;
		}

		// Если точка минимальнее всех остальных, то...
		if ((matr[x + 1][y] <= matr[x][y - 1]) && (matr[x + 1][y] <= matr[x][y + 1]) && (matr[x + 1][y] <= matr[x - 1][y]))
		{
			// Переходим в нее
			x = x + 1;
			y = y;

			// Если мы достигли первой волны, то хватит, алгоритм завершается
			if (matr[x][y] == 1)
			{
				matr[x][y] = 998;
				break;
			}
			// Заменяем её на 998 (то есть означает, что это путь минимальный)
			matr[x][y] = 998;
			continue;
		}
	}
	return 1;
}

int main()
{
	setlocale(LC_ALL, "RUS");
	int xA = -5, yA = -5, xB = -5, yB = -5;

	// Печатаем пустую матрицу
	print_matr();

	// Задаем координаты точек А и В
	setA(&xA, &yA, &xB, &yB);
	setB(&xB, &yB, &xA, &yA);

	// Снова печатаем матрицу
	print_matr();

	// Запускаем волновой алгоритм и...
	WAVE(xA, yA, xB, yB);
	// печатаем матрицу в цифрах, чтобы показать как он работает
	print();

	// Ищем минимальный путь, и, если он будет найден, то...
	if (FIND_WAY(xB, yB) == 1)
		print_matr(); // печатаем матрицу, чтобы на него посмотреть (если он будет не найден будет соответствующее сообщение
	// и матрица не распечатается)

	cout << endl;
	system("PAUSE");
	return 0;
}
